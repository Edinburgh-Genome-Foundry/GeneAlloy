{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GeneAlloy Genealloy helps designing overlapping sequences. It takes two amino acid coding nucleotide sequences and a codon conversion table of allowed triplet -> triplet transitions, and determines whether one sequence can be inserted into the other one. Note that the package is under development. Overlapping sequences are nucleotide sequences that encode different amino acid sequences on the same DNA or RNA region. These sequences are either on the complementary strands (in any frame), or on the same strand as frameshift sequences. This phenomenon is made possible by the redundancy of the genetic code (codon degeneracy). In the metallurgic terminology used at the genome foundries, the host sequence (into which the shorter sequence is inserted) is called the matrix or solvent, and the shorter guest (or parasite) is called the solute; and a combination sequence is called a genealloy. Install pip install git+https://github.com/Edinburgh-Genome-Foundry/GeneAlloy.git Usage import genealloy as ga swaptable = ga . generate_swaptable ( ga . codon_to_aa , ga . aa_to_codon_extended ) host = 'TCGTCGTACCAGCCGCAGAGGAGAGCTACTTTT' parasite = 'GTACCCGCTGCG' # frameshift 2 ga . make_genealloy ( host , parasite , swaptable ) Find partial overlaps: ga.find_partial_overlaps(host, parasite, swaptable) Version The GeneAlloy project uses the semantic versioning scheme. The package is under development. License = MIT Genealloy is free software , which means the users have the freedom to run, copy, distribute, study, change and improve the software. Genealloy was written at the Edinburgh Genome Foundry by Peter Vegh and is released under the MIT license.","title":"Home"},{"location":"#genealloy","text":"Genealloy helps designing overlapping sequences. It takes two amino acid coding nucleotide sequences and a codon conversion table of allowed triplet -> triplet transitions, and determines whether one sequence can be inserted into the other one. Note that the package is under development. Overlapping sequences are nucleotide sequences that encode different amino acid sequences on the same DNA or RNA region. These sequences are either on the complementary strands (in any frame), or on the same strand as frameshift sequences. This phenomenon is made possible by the redundancy of the genetic code (codon degeneracy). In the metallurgic terminology used at the genome foundries, the host sequence (into which the shorter sequence is inserted) is called the matrix or solvent, and the shorter guest (or parasite) is called the solute; and a combination sequence is called a genealloy.","title":"GeneAlloy"},{"location":"#install","text":"pip install git+https://github.com/Edinburgh-Genome-Foundry/GeneAlloy.git","title":"Install"},{"location":"#usage","text":"import genealloy as ga swaptable = ga . generate_swaptable ( ga . codon_to_aa , ga . aa_to_codon_extended ) host = 'TCGTCGTACCAGCCGCAGAGGAGAGCTACTTTT' parasite = 'GTACCCGCTGCG' # frameshift 2 ga . make_genealloy ( host , parasite , swaptable ) Find partial overlaps: ga.find_partial_overlaps(host, parasite, swaptable)","title":"Usage"},{"location":"#version","text":"The GeneAlloy project uses the semantic versioning scheme. The package is under development.","title":"Version"},{"location":"#license-mit","text":"Genealloy is free software , which means the users have the freedom to run, copy, distribute, study, change and improve the software. Genealloy was written at the Edinburgh Genome Foundry by Peter Vegh and is released under the MIT license.","title":"License = MIT"},{"location":"reference/genealloy/","text":"Module genealloy View Source from .codontable import ( codon_to_aa , aa_to_codon_extended , codon_extended_to_aa , ambiguity_code_to_nt_set , allowed_aa_transitions , make_transition_dictionary , generate_swaptable , compare_letters , ) from .genealloy import ( convert_seq_to_codons , convert_codonlist_to_tuplelist , compare_then_get_letter_recursively , walk_seqstep , compare_sequence_tuplelists , compare_sequence_tuplelists_in_all_frames , find_partial_overlaps , make_genealloy , get_complement_tuplelist , get_reverse_tuplelist , get_reverse_complement_tuplelist , SeqStep , ) from .version import __version__ Sub-modules genealloy.codontable genealloy.genealloy genealloy.version Variables aa_to_codon_extended allowed_aa_transitions ambiguity_code_to_nt_set codon_extended_to_aa codon_to_aa","title":"Index"},{"location":"reference/genealloy/#module-genealloy","text":"View Source from .codontable import ( codon_to_aa , aa_to_codon_extended , codon_extended_to_aa , ambiguity_code_to_nt_set , allowed_aa_transitions , make_transition_dictionary , generate_swaptable , compare_letters , ) from .genealloy import ( convert_seq_to_codons , convert_codonlist_to_tuplelist , compare_then_get_letter_recursively , walk_seqstep , compare_sequence_tuplelists , compare_sequence_tuplelists_in_all_frames , find_partial_overlaps , make_genealloy , get_complement_tuplelist , get_reverse_tuplelist , get_reverse_complement_tuplelist , SeqStep , ) from .version import __version__","title":"Module genealloy"},{"location":"reference/genealloy/#sub-modules","text":"genealloy.codontable genealloy.genealloy genealloy.version","title":"Sub-modules"},{"location":"reference/genealloy/#variables","text":"aa_to_codon_extended allowed_aa_transitions ambiguity_code_to_nt_set codon_extended_to_aa codon_to_aa","title":"Variables"},{"location":"reference/genealloy/codontable/","text":"Module genealloy.codontable Codon to amino acid dictionary View Source \"\"\"Codon to amino acid dictionary\"\"\" codon_to_aa = { \"TTT\" : \"F\" , \"TTC\" : \"F\" , \"TTA\" : \"L\" , \"TTG\" : \"L\" , \"TCT\" : \"S\" , \"TCC\" : \"S\" , \"TCA\" : \"S\" , \"TCG\" : \"S\" , \"TAT\" : \"Y\" , \"TAC\" : \"Y\" , \"TAA\" : \"*\" , \"TAG\" : \"*\" , \"TGT\" : \"C\" , \"TGC\" : \"C\" , \"TGA\" : \"*\" , \"TGG\" : \"W\" , \"CTT\" : \"L\" , \"CTC\" : \"L\" , \"CTA\" : \"L\" , \"CTG\" : \"L\" , \"CCT\" : \"P\" , \"CCC\" : \"P\" , \"CCA\" : \"P\" , \"CCG\" : \"P\" , \"CAT\" : \"H\" , \"CAC\" : \"H\" , \"CAA\" : \"Q\" , \"CAG\" : \"Q\" , \"CGT\" : \"R\" , \"CGC\" : \"R\" , \"CGA\" : \"R\" , \"CGG\" : \"R\" , \"ATT\" : \"I\" , \"ATC\" : \"I\" , \"ATA\" : \"I\" , \"ATG\" : \"M\" , \"ACT\" : \"T\" , \"ACC\" : \"T\" , \"ACA\" : \"T\" , \"ACG\" : \"T\" , \"AAT\" : \"N\" , \"AAC\" : \"N\" , \"AAA\" : \"K\" , \"AAG\" : \"K\" , \"AGT\" : \"S\" , \"AGC\" : \"S\" , \"AGA\" : \"R\" , \"AGG\" : \"R\" , \"GTT\" : \"V\" , \"GTC\" : \"V\" , \"GTA\" : \"V\" , \"GTG\" : \"V\" , \"GCT\" : \"A\" , \"GCC\" : \"A\" , \"GCA\" : \"A\" , \"GCG\" : \"A\" , \"GAT\" : \"D\" , \"GAC\" : \"D\" , \"GAA\" : \"E\" , \"GAG\" : \"E\" , \"GGT\" : \"G\" , \"GGC\" : \"G\" , \"GGA\" : \"G\" , \"GGG\" : \"G\" , } \"\"\"Amino acid to codon dictionary, using extended nucleotide letters\"\"\" aa_to_codon_extended = { \"A\" : [ \"GCX\" ] , \"B\" : [ \"RAY\" ] , \"C\" : [ \"TGY\" ] , \"D\" : [ \"GAY\" ] , \"E\" : [ \"GAR\" ] , \"F\" : [ \"TTY\" ] , \"G\" : [ \"GGX\" ] , \"H\" : [ \"CAY\" ] , \"I\" : [ \"ATH\" ] , # 'J' : [ '-' ] , \"K\" : [ \"AAR\" ] , \"L\" : [ \"TTR\", \"CTX\", \"YTR\" ] , \"M\" : [ \"ATG\" ] , \"N\" : [ \"AAY\" ] , # 'O' : [ '-' ] , \"P\" : [ \"CCX\" ] , \"Q\" : [ \"CAR\" ] , \"R\" : [ \"CGX\", \"AGR\", \"MGR\" ] , \"S\" : [ \"TCX\", \"AGY\" ] , \"T\" : [ \"ACX\" ] , # \"U\" : [ \"-\" ] , \"V\" : [ \"GTX\" ] , \"W\" : [ \"TGG\" ] , \"X\" : [ \"XXX\" ] , \"Y\" : [ \"TAY\" ] , \"Z\" : [ \"SAR\" ] , \".\" : [ \"-\" ] , # no amino acid ( deletion or gap ) \"*\" : [ \"TAR\", \"TRA\" ] , # STOP codons } \"\"\"Codon to amino acid dictionary, using extended nucleotide letters\"\"\" codon_extended_to_aa = { \"GCX\" : \"A\" , \"RAY\" : \"B\" , \"TGY\" : \"C\" , \"GAY\" : \"D\" , \"GAR\" : \"E\" , \"TTY\" : \"F\" , \"GGX\" : \"G\" , \"CAY\" : \"H\" , \"ATH\" : \"I\" , # \"-\" : \"J\" , \"AAR\" : \"K\" , \"TTR\" : \"L\" , \"CTX\" : \"L\" , \"YTR\" : \"L\" , \"ATG\" : \"M\" , \"AAY\" : \"N\" , # \"-\" : \"O\" , \"CCX\" : \"P\" , \"CAR\" : \"Q\" , \"CGX\" : \"R\" , \"AGR\" : \"R\" , \"MGR\" : \"R\" , \"TCX\" : \"S\" , \"AGY\" : \"S\" , \"ACX\" : \"T\" , # \"-\" : \"U\" , \"GTX\" : \"V\" , \"TGG\" : \"W\" , \"XXX\" : \"X\" , \"TAY\" : \"Y\" , \"SAR\" : \"Z\" , # \"-\" : \".\" , # no amino acid ( deletion or gap ) \"TAR\" : \"*\" , # STOP codon \"TRA\" : \"*\" , # STOP codon } \"\"\"Extended nucleotide letter to nucleotide letter dictionary\"\"\" ambiguity_code_to_nt_set = { \"A\" : { \"A\" } , \"G\" : { \"G\" } , \"C\" : { \"C\" } , \"T\" : { \"T\" } , \"Y\" : { \"C\" , \"T\" } , \"R\" : { \"A\" , \"G\" } , \"W\" : { \"A\" , \"T\" } , \"S\" : { \"G\" , \"C\" } , \"K\" : { \"T\" , \"G\" } , \"M\" : { \"C\" , \"A\" } , \"D\" : { \"A\" , \"G\" , \"T\" } , \"V\" : { \"A\" , \"C\" , \"G\" } , \"H\" : { \"A\" , \"C\" , \"T\" } , \"B\" : { \"C\" , \"G\" , \"T\" } , \"X\" : { \"A\" , \"C\" , \"G\" , \"T\" } , \"N\" : { \"A\" , \"C\" , \"G\" , \"T\" } , } \"\"\"Extended nucleotide letter to complement letter dictionary\"\"\" complement_table = { \"A\" : \"T\" , \"G\" : \"C\" , \"C\" : \"G\" , \"T\" : \"A\" , \"Y\" : \"R\" , \"R\" : \"Y\" , \"W\" : \"W\" , \"S\" : \"S\" , \"K\" : \"M\" , \"M\" : \"K\" , \"D\" : \"H\" , \"V\" : \"B\" , \"H\" : \"D\" , \"B\" : \"V\" , \"X\" : \"X\" , \"N\" : \"N\" , } allowed_aa_transitions = { \"A\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , \"B\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \"C\" : [ \"S\", \"C\", \"M\", \"T\" ] , \"D\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \"E\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \"F\" : [ \"F\", \"Y\", \"W\" ] , \"G\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , \"H\" : [ \"H\", \"K\", \"R\" ] , \"I\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , # 'J' : [ 'J' ] , \"K\" : [ \"H\", \"K\", \"R\" ] , \"L\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , \"M\" : [ \"S\", \"C\", \"M\", \"T\" ] , \"N\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , # 'O' : [ 'O' ] , \"P\" : [ \"P\" ] , \"Q\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \"R\" : [ \"H\", \"K\", \"R\" ] , \"S\" : [ \"S\", \"C\", \"M\", \"T\" ] , \"T\" : [ \"S\", \"C\", \"M\", \"T\" ] , # \"U\" : [ 'S', 'C', 'U', 'M', 'T' ] , \"V\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , \"W\" : [ \"F\", \"Y\", \"W\" ] , \"X\" : [ \"X\" ] , \"Y\" : [ \"F\", \"Y\", \"W\" ] , \"Z\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \".\" : [ \".\" ] , \"*\" : [ \"*\" ] , } def make_transition_dictionary ( aa_to_codon_extended , allowed_aa_transitions ) : transition_dictionary = {} for aa , aa_list in allowed_aa_transitions . items () : codons = [] for aa_element in aa_list : triplets_to_add = aa_to_codon_extended [ aa_element ] codons = codons + triplets_to_add transition_dictionary [ aa ] = codons return transition_dictionary # TODO rename aa_to_codon_extended --> transition_dictionary and references elsewhere def generate_swaptable ( codon_to_aa , aa_to_codon_extended ) : \"\"\"Generate a codon to extended codon dictionary\"\"\" codon_to_codon_extended = dict () for k , v in codon_to_aa . items () : codon_to_codon_extended [ k ] = tuple ( aa_to_codon_extended [ v ] ) return codon_to_codon_extended def compare_letters ( letter1 , letter2 , table = ambiguity_code_to_nt_set ) : \"\"\"Compare two extended nucleotide letters and return True if they match\"\"\" set1 = table [ letter1 ] set2 = table [ letter2 ] if set1 & set2 != set () : is_match = True else : is_match = False return is_match Variables aa_to_codon_extended Codon to amino acid dictionary, using extended nucleotide letters allowed_aa_transitions ambiguity_code_to_nt_set Extended nucleotide letter to complement letter dictionary codon_extended_to_aa Extended nucleotide letter to nucleotide letter dictionary codon_to_aa Amino acid to codon dictionary, using extended nucleotide letters complement_table Functions compare_letters def compare_letters ( letter1 , letter2 , table = { 'A' : { 'A' }, 'G' : { 'G' }, 'C' : { 'C' }, 'T' : { 'T' }, 'Y' : { 'C' , 'T' }, 'R' : { 'G' , 'A' }, 'W' : { 'A' , 'T' }, 'S' : { 'G' , 'C' }, 'K' : { 'G' , 'T' }, 'M' : { 'A' , 'C' }, 'D' : { 'G' , 'A' , 'T' }, 'V' : { 'G' , 'A' , 'C' }, 'H' : { 'A' , 'C' , 'T' }, 'B' : { 'G' , 'C' , 'T' }, 'X' : { 'G' , 'A' , 'C' , 'T' }, 'N' : { 'G' , 'A' , 'C' , 'T' }} ) Compare two extended nucleotide letters and return True if they match View Source def compare_letters ( letter1 , letter2 , table = ambiguity_code_to_nt_set ) : \"\"\"Compare two extended nucleotide letters and return True if they match\"\"\" set1 = table [ letter1 ] set2 = table [ letter2 ] if set1 & set2 != set () : is_match = True else : is_match = False return is_match generate_swaptable def generate_swaptable ( codon_to_aa , aa_to_codon_extended ) Generate a codon to extended codon dictionary View Source def generate_swaptable ( codon_to_aa , aa_to_codon_extended ) : \"\"\"Generate a codon to extended codon dictionary\"\"\" codon_to_codon_extended = dict () for k , v in codon_to_aa . items () : codon_to_codon_extended [ k ] = tuple ( aa_to_codon_extended [ v ] ) return codon_to_codon_extended make_transition_dictionary def make_transition_dictionary ( aa_to_codon_extended , allowed_aa_transitions ) View Source def make_transition_dictionary ( aa_to_codon_extended , allowed_aa_transitions ) : transition_dictionary = {} for aa , aa_list in allowed_aa_transitions . items () : codons = [] for aa_element in aa_list : triplets_to_add = aa_to_codon_extended [ aa_element ] codons = codons + triplets_to_add transition_dictionary [ aa ] = codons return transition_dictionary","title":"Codontable"},{"location":"reference/genealloy/codontable/#module-genealloycodontable","text":"Codon to amino acid dictionary View Source \"\"\"Codon to amino acid dictionary\"\"\" codon_to_aa = { \"TTT\" : \"F\" , \"TTC\" : \"F\" , \"TTA\" : \"L\" , \"TTG\" : \"L\" , \"TCT\" : \"S\" , \"TCC\" : \"S\" , \"TCA\" : \"S\" , \"TCG\" : \"S\" , \"TAT\" : \"Y\" , \"TAC\" : \"Y\" , \"TAA\" : \"*\" , \"TAG\" : \"*\" , \"TGT\" : \"C\" , \"TGC\" : \"C\" , \"TGA\" : \"*\" , \"TGG\" : \"W\" , \"CTT\" : \"L\" , \"CTC\" : \"L\" , \"CTA\" : \"L\" , \"CTG\" : \"L\" , \"CCT\" : \"P\" , \"CCC\" : \"P\" , \"CCA\" : \"P\" , \"CCG\" : \"P\" , \"CAT\" : \"H\" , \"CAC\" : \"H\" , \"CAA\" : \"Q\" , \"CAG\" : \"Q\" , \"CGT\" : \"R\" , \"CGC\" : \"R\" , \"CGA\" : \"R\" , \"CGG\" : \"R\" , \"ATT\" : \"I\" , \"ATC\" : \"I\" , \"ATA\" : \"I\" , \"ATG\" : \"M\" , \"ACT\" : \"T\" , \"ACC\" : \"T\" , \"ACA\" : \"T\" , \"ACG\" : \"T\" , \"AAT\" : \"N\" , \"AAC\" : \"N\" , \"AAA\" : \"K\" , \"AAG\" : \"K\" , \"AGT\" : \"S\" , \"AGC\" : \"S\" , \"AGA\" : \"R\" , \"AGG\" : \"R\" , \"GTT\" : \"V\" , \"GTC\" : \"V\" , \"GTA\" : \"V\" , \"GTG\" : \"V\" , \"GCT\" : \"A\" , \"GCC\" : \"A\" , \"GCA\" : \"A\" , \"GCG\" : \"A\" , \"GAT\" : \"D\" , \"GAC\" : \"D\" , \"GAA\" : \"E\" , \"GAG\" : \"E\" , \"GGT\" : \"G\" , \"GGC\" : \"G\" , \"GGA\" : \"G\" , \"GGG\" : \"G\" , } \"\"\"Amino acid to codon dictionary, using extended nucleotide letters\"\"\" aa_to_codon_extended = { \"A\" : [ \"GCX\" ] , \"B\" : [ \"RAY\" ] , \"C\" : [ \"TGY\" ] , \"D\" : [ \"GAY\" ] , \"E\" : [ \"GAR\" ] , \"F\" : [ \"TTY\" ] , \"G\" : [ \"GGX\" ] , \"H\" : [ \"CAY\" ] , \"I\" : [ \"ATH\" ] , # 'J' : [ '-' ] , \"K\" : [ \"AAR\" ] , \"L\" : [ \"TTR\", \"CTX\", \"YTR\" ] , \"M\" : [ \"ATG\" ] , \"N\" : [ \"AAY\" ] , # 'O' : [ '-' ] , \"P\" : [ \"CCX\" ] , \"Q\" : [ \"CAR\" ] , \"R\" : [ \"CGX\", \"AGR\", \"MGR\" ] , \"S\" : [ \"TCX\", \"AGY\" ] , \"T\" : [ \"ACX\" ] , # \"U\" : [ \"-\" ] , \"V\" : [ \"GTX\" ] , \"W\" : [ \"TGG\" ] , \"X\" : [ \"XXX\" ] , \"Y\" : [ \"TAY\" ] , \"Z\" : [ \"SAR\" ] , \".\" : [ \"-\" ] , # no amino acid ( deletion or gap ) \"*\" : [ \"TAR\", \"TRA\" ] , # STOP codons } \"\"\"Codon to amino acid dictionary, using extended nucleotide letters\"\"\" codon_extended_to_aa = { \"GCX\" : \"A\" , \"RAY\" : \"B\" , \"TGY\" : \"C\" , \"GAY\" : \"D\" , \"GAR\" : \"E\" , \"TTY\" : \"F\" , \"GGX\" : \"G\" , \"CAY\" : \"H\" , \"ATH\" : \"I\" , # \"-\" : \"J\" , \"AAR\" : \"K\" , \"TTR\" : \"L\" , \"CTX\" : \"L\" , \"YTR\" : \"L\" , \"ATG\" : \"M\" , \"AAY\" : \"N\" , # \"-\" : \"O\" , \"CCX\" : \"P\" , \"CAR\" : \"Q\" , \"CGX\" : \"R\" , \"AGR\" : \"R\" , \"MGR\" : \"R\" , \"TCX\" : \"S\" , \"AGY\" : \"S\" , \"ACX\" : \"T\" , # \"-\" : \"U\" , \"GTX\" : \"V\" , \"TGG\" : \"W\" , \"XXX\" : \"X\" , \"TAY\" : \"Y\" , \"SAR\" : \"Z\" , # \"-\" : \".\" , # no amino acid ( deletion or gap ) \"TAR\" : \"*\" , # STOP codon \"TRA\" : \"*\" , # STOP codon } \"\"\"Extended nucleotide letter to nucleotide letter dictionary\"\"\" ambiguity_code_to_nt_set = { \"A\" : { \"A\" } , \"G\" : { \"G\" } , \"C\" : { \"C\" } , \"T\" : { \"T\" } , \"Y\" : { \"C\" , \"T\" } , \"R\" : { \"A\" , \"G\" } , \"W\" : { \"A\" , \"T\" } , \"S\" : { \"G\" , \"C\" } , \"K\" : { \"T\" , \"G\" } , \"M\" : { \"C\" , \"A\" } , \"D\" : { \"A\" , \"G\" , \"T\" } , \"V\" : { \"A\" , \"C\" , \"G\" } , \"H\" : { \"A\" , \"C\" , \"T\" } , \"B\" : { \"C\" , \"G\" , \"T\" } , \"X\" : { \"A\" , \"C\" , \"G\" , \"T\" } , \"N\" : { \"A\" , \"C\" , \"G\" , \"T\" } , } \"\"\"Extended nucleotide letter to complement letter dictionary\"\"\" complement_table = { \"A\" : \"T\" , \"G\" : \"C\" , \"C\" : \"G\" , \"T\" : \"A\" , \"Y\" : \"R\" , \"R\" : \"Y\" , \"W\" : \"W\" , \"S\" : \"S\" , \"K\" : \"M\" , \"M\" : \"K\" , \"D\" : \"H\" , \"V\" : \"B\" , \"H\" : \"D\" , \"B\" : \"V\" , \"X\" : \"X\" , \"N\" : \"N\" , } allowed_aa_transitions = { \"A\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , \"B\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \"C\" : [ \"S\", \"C\", \"M\", \"T\" ] , \"D\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \"E\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \"F\" : [ \"F\", \"Y\", \"W\" ] , \"G\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , \"H\" : [ \"H\", \"K\", \"R\" ] , \"I\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , # 'J' : [ 'J' ] , \"K\" : [ \"H\", \"K\", \"R\" ] , \"L\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , \"M\" : [ \"S\", \"C\", \"M\", \"T\" ] , \"N\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , # 'O' : [ 'O' ] , \"P\" : [ \"P\" ] , \"Q\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \"R\" : [ \"H\", \"K\", \"R\" ] , \"S\" : [ \"S\", \"C\", \"M\", \"T\" ] , \"T\" : [ \"S\", \"C\", \"M\", \"T\" ] , # \"U\" : [ 'S', 'C', 'U', 'M', 'T' ] , \"V\" : [ \"G\", \"A\", \"V\", \"L\", \"I\" ] , \"W\" : [ \"F\", \"Y\", \"W\" ] , \"X\" : [ \"X\" ] , \"Y\" : [ \"F\", \"Y\", \"W\" ] , \"Z\" : [ \"D\", \"E\", \"N\", \"Q\", \"B\", \"Z\" ] , \".\" : [ \".\" ] , \"*\" : [ \"*\" ] , } def make_transition_dictionary ( aa_to_codon_extended , allowed_aa_transitions ) : transition_dictionary = {} for aa , aa_list in allowed_aa_transitions . items () : codons = [] for aa_element in aa_list : triplets_to_add = aa_to_codon_extended [ aa_element ] codons = codons + triplets_to_add transition_dictionary [ aa ] = codons return transition_dictionary # TODO rename aa_to_codon_extended --> transition_dictionary and references elsewhere def generate_swaptable ( codon_to_aa , aa_to_codon_extended ) : \"\"\"Generate a codon to extended codon dictionary\"\"\" codon_to_codon_extended = dict () for k , v in codon_to_aa . items () : codon_to_codon_extended [ k ] = tuple ( aa_to_codon_extended [ v ] ) return codon_to_codon_extended def compare_letters ( letter1 , letter2 , table = ambiguity_code_to_nt_set ) : \"\"\"Compare two extended nucleotide letters and return True if they match\"\"\" set1 = table [ letter1 ] set2 = table [ letter2 ] if set1 & set2 != set () : is_match = True else : is_match = False return is_match","title":"Module genealloy.codontable"},{"location":"reference/genealloy/codontable/#variables","text":"aa_to_codon_extended Codon to amino acid dictionary, using extended nucleotide letters allowed_aa_transitions ambiguity_code_to_nt_set Extended nucleotide letter to complement letter dictionary codon_extended_to_aa Extended nucleotide letter to nucleotide letter dictionary codon_to_aa Amino acid to codon dictionary, using extended nucleotide letters complement_table","title":"Variables"},{"location":"reference/genealloy/codontable/#functions","text":"","title":"Functions"},{"location":"reference/genealloy/codontable/#compare_letters","text":"def compare_letters ( letter1 , letter2 , table = { 'A' : { 'A' }, 'G' : { 'G' }, 'C' : { 'C' }, 'T' : { 'T' }, 'Y' : { 'C' , 'T' }, 'R' : { 'G' , 'A' }, 'W' : { 'A' , 'T' }, 'S' : { 'G' , 'C' }, 'K' : { 'G' , 'T' }, 'M' : { 'A' , 'C' }, 'D' : { 'G' , 'A' , 'T' }, 'V' : { 'G' , 'A' , 'C' }, 'H' : { 'A' , 'C' , 'T' }, 'B' : { 'G' , 'C' , 'T' }, 'X' : { 'G' , 'A' , 'C' , 'T' }, 'N' : { 'G' , 'A' , 'C' , 'T' }} ) Compare two extended nucleotide letters and return True if they match View Source def compare_letters ( letter1 , letter2 , table = ambiguity_code_to_nt_set ) : \"\"\"Compare two extended nucleotide letters and return True if they match\"\"\" set1 = table [ letter1 ] set2 = table [ letter2 ] if set1 & set2 != set () : is_match = True else : is_match = False return is_match","title":"compare_letters"},{"location":"reference/genealloy/codontable/#generate_swaptable","text":"def generate_swaptable ( codon_to_aa , aa_to_codon_extended ) Generate a codon to extended codon dictionary View Source def generate_swaptable ( codon_to_aa , aa_to_codon_extended ) : \"\"\"Generate a codon to extended codon dictionary\"\"\" codon_to_codon_extended = dict () for k , v in codon_to_aa . items () : codon_to_codon_extended [ k ] = tuple ( aa_to_codon_extended [ v ] ) return codon_to_codon_extended","title":"generate_swaptable"},{"location":"reference/genealloy/codontable/#make_transition_dictionary","text":"def make_transition_dictionary ( aa_to_codon_extended , allowed_aa_transitions ) View Source def make_transition_dictionary ( aa_to_codon_extended , allowed_aa_transitions ) : transition_dictionary = {} for aa , aa_list in allowed_aa_transitions . items () : codons = [] for aa_element in aa_list : triplets_to_add = aa_to_codon_extended [ aa_element ] codons = codons + triplets_to_add transition_dictionary [ aa ] = codons return transition_dictionary","title":"make_transition_dictionary"},{"location":"reference/genealloy/genealloy/","text":"Module genealloy.genealloy View Source from . codontable import ( codon_to_aa , aa_to_codon_extended , codon_extended_to_aa , complement_table , compare_letters , ) def convert_seq_to_codons ( seq ) : \"\"\"Convert a string (sequence) into a list of 3-letter strings (triplets).\"\"\" seq_codons = [ seq [ i : i + 3 ] for i in range ( 0 , len ( seq ), 3 )] return seq_codons def convert_codonlist_to_tuplelist ( seq_codons , codon_to_codon_extended ) : \"\"\"Convert a list of triplets into a list of tuples, using a swaptable. The swaptable is a dict of triplet: triplets, and determines the allowed swaps. \"\"\" codon_extended = [ None ] * len ( seq_codons ) for i , codon in enumerate ( seq_codons ) : codon_extended [ i ] = codon_to_codon_extended [ codon ] return codon_extended def get_next_letter ( sequence_tuplelist , current_letter_index ) : \"\"\"Get next letter in the sequence.\"\"\" letter_index = current_letter_index if current_letter_index [ 2 ] == 2 : # last letter of triplet , advance to next codon : letter_index = [ letter_index [ 0 ] + 1 , 0 , 0 ] try : i , j , k = letter_index [ 0 ], letter_index [ 1 ], letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ], letter_index ) return letter except : raise else : # letter is not the last in triplet , get the next one : letter_index [ 2 ] = letter_index [ 2 ] + 1 i , j , k = letter_index [ 0 ], letter_index [ 1 ], letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ], letter_index ) return letter def get_letter_in_next_triplet ( sequence_tuplelist , current_letter_index ) : \"\"\"Get first letter in the next triplet.\"\"\" letter_index = current_letter_index letter_index [ 1 ] = letter_index [ 1 ] + 1 # triplet position letter_index [ 2 ] = 0 # move letter position to triplet's first letter try: i, j, k = letter_index[0], letter_index[1], letter_index[2] letter = (sequence_tuplelist[i][j][k], letter_index) return letter except: raise def compare_then_get_letter_recursively( host_tuplelist, parasite_tuplelist, host_letter, parasite_letter ): \"\"\"Compare two letters then get next pair of letters recursively. Returns string for match or no match between the sequences. \"\"\" # This function works only for in-frame comparisons and is given the first # letters of the host and parasite sequences. If the two letters match, # then gets the next parasite and host letters, and calls itself. # If can't get next parasite letter , then the comparison has finished # and a full match has been found . # If letters do not match , then gets the next parasite triplet and calls # itself ; if there are no more parasite triplets , it gets the next host # triplet and calls itself . If there are no more host triplets , then there is # no match between the sequences . is_match = compare_letters ( host_letter [ 0 ], parasite_letter [ 0 ]) if is_match: try : next_parasite_letter = get_next_letter ( parasite_tuplelist , parasite_letter [ 1 ] ) except : return str ( \"Finished parasite sequence, match found! Ending host position:\" + str ( host_letter [ 1 ]) ) else : next_host_letter = get_next_letter ( host_tuplelist , host_letter [ 1 ] ) # always OK return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) else : # letters do not match , move on to next parasite triplet try : next_parasite_letter = get_letter_in_next_triplet ( parasite_tuplelist , parasite_letter [ 1 ] ) except : # no more parasite triplet , get next host try : next_host_letter = get_letter_in_next_triplet ( host_tuplelist , host_letter [ 1 ] ) except : return \"No match for this starting codon position\" else : i = parasite_letter [ 1 ][ 0 ] # same codon j , k = 0 , 0 # reset parasite to first triplet , first letter next_parasite_letter = ( parasite_tuplelist [ i ][ j ][ k ], [ i , j , k ]) return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) else : i , j = host_letter [ 1 ][ 0 ], host_letter [ 1 ][ 1 ] # same codon , same triplet k = 0 # reset host letter to beginning of triplet because parasite was reset next_host_letter = ( host_tuplelist [ i ][ j ][ k ], [ i , j , k ]) return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) def walk_seqstep ( seqstep ) : \"\"\"Compare two sequences by calling `advance_step` until it returns the result.\"\"\" while not seqstep . result : seqstep . advance_step () def compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ) : \"\"\"Compare two sequence's tuplists for given frame and return list of matches.\"\"\" len_parasite = len ( parasite_tuplelist ) len_host = len ( host_tuplelist ) list_of_matches = [] for start_host_codon in range ( 0 , len_host - len_parasite + 1 ) : seqstep = SeqStep ( host_tuplelist , parasite_tuplelist , start_host_codon = start_host_codon , frameshift = frameshift , ) walk_seqstep ( seqstep ) if seqstep . match : list_of_matches . append ( start_host_codon ) return list_of_matches def compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix= \"\" ) : \"\"\"Compare two sequence's tuplists for all frames and return dict of matches.\"\"\" results_for_all_frames = dict () for frameshift in [ 0 , 1 , 2 ] : result = compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ) key = prefix + str ( frameshift ) results_for_all_frames [ key ] = result return results_for_all_frames def find_partial_overlaps ( host , parasite , swaptable , verbose = True ) : flank = len ( parasite ) * \"N\" host_flank = flank + host + flank swaptable [ \"NNN\" ] = ( \"NNN\" ,) result = make_genealloy ( host_flank , parasite , swaptable , verbose = True ) return result def make_genealloy ( host , parasite , swaptable , verbose = True ) : \"\"\"Compare two sequence strings and return dictionary of matches.\"\"\" host_codons = convert_seq_to_codons ( host ) host_tuplelist = convert_codonlist_to_tuplelist ( host_codons , swaptable ) parasite_codons = convert_seq_to_codons ( parasite ) parasite_tuplelist = convert_codonlist_to_tuplelist ( parasite_codons , swaptable ) forward_results = compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix= \"f_\" ) reverse_complement_tuplelist = get_reverse_complement_tuplelist ( host_tuplelist ) reverse_complement_results = compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , reverse_complement_tuplelist , prefix= \"rc_\" ) result = forward_results . copy () result . update ( reverse_complement_results ) if verbose : if all ( value == [] for value in result . values ()) : print ( \"These sequences cannot be mixed\" ) else : print ( \"A genealloy can be made using these sequences!\" ) return result def get_complement_tuplelist ( codon_tuplelist ) : \"\"\"Get complement triplets of a sequence tuplelist.\"\"\" complement_tuplelist = [] for index , codon in enumerate ( codon_tuplelist ) : complement_tripletlist = [] for triplet in codon : letter1 = triplet [ 0 ] letter2 = triplet [ 1 ] letter3 = triplet [ 2 ] complement_triplet = ( complement_table [ letter1 ] + complement_table [ letter2 ] + complement_table [ letter3 ] ) complement_tripletlist . append ( complement_triplet ) complement_codon = tuple ( complement_tripletlist ) complement_tuplelist . append ( complement_codon ) return complement_tuplelist def get_reverse_tuplelist ( codon_tuplelist ) : \"\"\"Get reverse of a tuplelist with reversed triplets.\"\"\" reverse_tuplelist = [] for codon in reversed ( codon_tuplelist ) : reverse_tripletlist = [] for triplet in codon : reverse_triplet = triplet [ ::- 1 ] reverse_tripletlist . append ( reverse_triplet ) reverse_codon = tuple ( reverse_tripletlist ) reverse_tuplelist . append ( reverse_codon ) return reverse_tuplelist def get_reverse_complement_tuplelist ( codon_tuplelist ) : \"\"\"Get reverse complement of a sequence's tuplelist.\"\"\" complement_tuplelist = get_complement_tuplelist ( codon_tuplelist ) reverse_complement_tuplelist = get_reverse_tuplelist ( complement_tuplelist ) return reverse_complement_tuplelist class Duodon : \"\"\"Class for storing two triplets\"\"\" def __ init__ ( self , first_triplet , second_triplet ) : self . first_triplet = first_triplet self . second_triplet = second_triplet class SeqStep : \"\"\"Class for keeping track of sequence comparison It stores a method that aligns a parasite triplet with two consecutive host triplets (duodons), a cursor that marks the position of the comparison process, and methods for generating duodons and comparing them with triplets. The `advance_step()` method attempts to advance the comparison by one codon step. It can (i) advance the cursor or (ii) conclude that there is no match between the sequences, or (iii) conclude that there is a match. Parameters ---------- host_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the host sequence. parasite_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the parasite sequence. frameshift An integer (0, 1 or 2) denoting the frameshift between host and parasite. start_host_codon The host codon position from which the comparison should start. \"\"\" def __ init__ ( self , host_tuplelist , parasite_tuplelist , frameshift = 0 , start_host_codon = 0 ) : self . host_tuplelist = host_tuplelist self . parasite_tuplelist = parasite_tuplelist self . frameshift = frameshift self . start_host_codon = start_host_codon self . cursor = 0 self . len_parasite = len ( parasite_tuplelist ) self . len_host = len ( host_tuplelist ) self . parasite_path = [] self . host_path = [] self . match = False self . result = None def generate_duodons ( self ) : self . cursor self . start_host_codon duodons = [] host_codon = self . start_host_codon + self . cursor if self . host_path == [] : # first time it's made for triplet_1 in self.host_tuplelist[host_codon]: for triplet_2 in self.host_tuplelist[host_codon + 1]: duodons.append(Duodon(triplet_1, triplet_2)) else: triplet_1 = self.host_path[-1].second_triplet # of last used duodon try: for triplet_2 in self.host_tuplelist[host_codon + 1]: duodons.append(Duodon(triplet_1, triplet_2)) except: duodons.append(Duodon(triplet_1, \"NNN\")) return duodons def return_all_matching_duodons(self, triplet, duodons, frameshift=0): matching_duodons = [] for duodon in duodons: host_letters = duodon.first_triplet + duodon.second_triplet # compare 1st letter: if not compare_letters(host_letters[0 + frameshift], triplet[0]): continue if not compare_letters(host_letters[1 + frameshift], triplet[1]): continue if not compare_letters(host_letters[2 + frameshift], triplet[2]): continue matching_duodons.append(duodon) return matching_duodons def compare_triplet_and_duodon(self, triplet, duodon, frameshift=0): host_letters = duodon.first_triplet + duodon.second_triplet if not compare_letters(host_letters[0 + frameshift], triplet[0]): return False if not compare_letters(host_letters[1 + frameshift], triplet[1]): return False if not compare_letters(host_letters[2 + frameshift], triplet[2]): return False return True def advance_step(self): if self.result: return self.result if self.cursor == self.len_parasite: self.match = True self.result = ( \"Match found between parasite and host sequence. Start codon was: \" + str(self.start_host_codon) ) return self.result parasite_triplets = list(self.parasite_tuplelist[self.cursor]) host_duodons = self.generate_duodons() while True: try: parasite_triplet = parasite_triplets[0] except: self.result = \"Sequences don't match . Start codon was : \" + str( self.start_host_codon ) return self.result else: host_duodons_for_parasite_triplet = host_duodons[:] host_duodons_for_parasite_triplet = self.return_all_matching_duodons( parasite_triplet, host_duodons_for_parasite_triplet, frameshift=self.frameshift, ) self.parasite_path.append(parasite_triplet) while True: try: host_doudon = host_duodons_for_parasite_triplet[0] except: self.parasite_path.pop() del parasite_triplets[0] break else: if self.compare_triplet_and_duodon( parasite_triplet, host_doudon, frameshift=self.frameshift ): self.host_path.append(host_doudon) self.cursor += 1 return \" Codon matched , cursor advanced \" else : del host_duodons_for_parasite_triplet [ 0 ] Variables aa_to_codon_extended codon_extended_to_aa codon_to_aa complement_table Functions compare_sequence_tuplelists def compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ) Compare two sequence's tuplists for given frame and return list of matches. View Source def compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ): \"\"\"Compare two sequence's tuplists for given frame and return list of matches.\"\"\" len_parasite = len ( parasite_tuplelist ) len_host = len ( host_tuplelist ) list_of_matches = [] for start_host_codon in range ( 0 , len_host - len_parasite + 1 ): seqstep = SeqStep ( host_tuplelist , parasite_tuplelist , start_host_codon = start_host_codon , frameshift = frameshift , ) walk_seqstep ( seqstep ) if seqstep . match : list_of_matches . append ( start_host_codon ) return list_of_matches compare_sequence_tuplelists_in_all_frames def compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix = '' ) Compare two sequence's tuplists for all frames and return dict of matches. View Source def compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix = \"\" ) : \"\"\"Compare two sequence's tuplists for all frames and return dict of matches.\"\"\" results_for_all_frames = dict () for frameshift in [ 0, 1, 2 ] : result = compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ) key = prefix + str ( frameshift ) results_for_all_frames [ key ] = result return results_for_all_frames compare_then_get_letter_recursively def compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , host_letter , parasite_letter ) Compare two letters then get next pair of letters recursively. Returns string for match or no match between the sequences. View Source def compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , host_letter , parasite_letter ) : \"\"\"Compare two letters then get next pair of letters recursively. Returns string for match or no match between the sequences. \"\"\" # This function works only for in - frame comparisons and is given the first # letters of the host and parasite sequences . If the two letters match , # then gets the next parasite and host letters , and calls itself . # If can ' t get next parasite letter , then the comparison has finished # and a full match has been found . # If letters do not match , then gets the next parasite triplet and calls # itself ; if there are no more parasite triplets , it gets the next host # triplet and calls itself . If there are no more host triplets , then there is # no match between the sequences . is_match = compare_letters ( host_letter [ 0 ] , parasite_letter [ 0 ] ) if is_match : try : next_parasite_letter = get_next_letter ( parasite_tuplelist , parasite_letter [ 1 ] ) except : return str ( \"Finished parasite sequence, match found! Ending host position:\" + str ( host_letter [ 1 ] ) ) else : next_host_letter = get_next_letter ( host_tuplelist , host_letter [ 1 ] ) # always OK return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) else : # letters do not match , move on to next parasite triplet try : next_parasite_letter = get_letter_in_next_triplet ( parasite_tuplelist , parasite_letter [ 1 ] ) except : # no more parasite triplet , get next host try : next_host_letter = get_letter_in_next_triplet ( host_tuplelist , host_letter [ 1 ] ) except : return \"No match for this starting codon position\" else : i = parasite_letter [ 1 ][ 0 ] # same codon j , k = 0 , 0 # reset parasite to first triplet , first letter next_parasite_letter = ( parasite_tuplelist [ i ][ j ][ k ] , [ i, j, k ] ) return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) else : i , j = host_letter [ 1 ][ 0 ] , host_letter [ 1 ][ 1 ] # same codon , same triplet k = 0 # reset host letter to beginning of triplet because parasite was reset next_host_letter = ( host_tuplelist [ i ][ j ][ k ] , [ i, j, k ] ) return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) convert_codonlist_to_tuplelist def convert_codonlist_to_tuplelist ( seq_codons , codon_to_codon_extended ) Convert a list of triplets into a list of tuples, using a swaptable. The swaptable is a dict of triplet: triplets, and determines the allowed swaps. View Source def convert_codonlist_to_tuplelist ( seq_codons , codon_to_codon_extended ) : \"\"\"Convert a list of triplets into a list of tuples, using a swaptable. The swaptable is a dict of triplet: triplets, and determines the allowed swaps. \"\"\" codon_extended = [ None ] * len ( seq_codons ) for i , codon in enumerate ( seq_codons ) : codon_extended [ i ] = codon_to_codon_extended [ codon ] return codon_extended convert_seq_to_codons def convert_seq_to_codons ( seq ) Convert a string (sequence) into a list of 3-letter strings (triplets). View Source def convert_seq_to_codons ( seq ) : \"\"\"Convert a string (sequence) into a list of 3-letter strings (triplets).\"\"\" seq_codons = [ seq [ i : i + 3 ] for i in range ( 0 , len ( seq ), 3 )] return seq_codons find_partial_overlaps def find_partial_overlaps ( host , parasite , swaptable , verbose = True ) View Source def find_partial_overlaps ( host , parasite , swaptable , verbose = True ): flank = len ( parasite ) * \"N\" host_flank = flank + host + flank swaptable [ \"NNN\" ] = ( \"NNN\" ,) result = make_genealloy ( host_flank , parasite , swaptable , verbose = True ) return result get_complement_tuplelist def get_complement_tuplelist ( codon_tuplelist ) Get complement triplets of a sequence tuplelist. View Source def get_complement_tuplelist ( codon_tuplelist ) : \"\"\"Get complement triplets of a sequence tuplelist.\"\"\" complement_tuplelist = [] for index , codon in enumerate ( codon_tuplelist ) : complement_tripletlist = [] for triplet in codon : letter1 = triplet [ 0 ] letter2 = triplet [ 1 ] letter3 = triplet [ 2 ] complement_triplet = ( complement_table [ letter1 ] + complement_table [ letter2 ] + complement_table [ letter3 ] ) complement_tripletlist . append ( complement_triplet ) complement_codon = tuple ( complement_tripletlist ) complement_tuplelist . append ( complement_codon ) return complement_tuplelist get_letter_in_next_triplet def get_letter_in_next_triplet ( sequence_tuplelist , current_letter_index ) Get first letter in the next triplet. View Source def get_letter_in_next_triplet ( sequence_tuplelist , current_letter_index ) : \"\"\"Get first letter in the next triplet.\"\"\" letter_index = current_letter_index letter_index [ 1 ] = letter_index [ 1 ] + 1 # triplet position letter_index [ 2 ] = 0 # move letter position to triplet ' s first letter try : i , j , k = letter_index [ 0 ] , letter_index [ 1 ] , letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ] , letter_index ) return letter except : raise get_next_letter def get_next_letter ( sequence_tuplelist , current_letter_index ) Get next letter in the sequence. View Source def get_next_letter ( sequence_tuplelist , current_letter_index ) : \"\"\"Get next letter in the sequence.\"\"\" letter_index = current_letter_index if current_letter_index [ 2 ] == 2 : # last letter of triplet , advance to next codon : letter_index = [ letter_index[0 ] + 1 , 0 , 0 ] try : i , j , k = letter_index [ 0 ] , letter_index [ 1 ] , letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ] , letter_index ) return letter except : raise else : # letter is not the last in triplet , get the next one : letter_index [ 2 ] = letter_index [ 2 ] + 1 i , j , k = letter_index [ 0 ] , letter_index [ 1 ] , letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ] , letter_index ) return letter get_reverse_complement_tuplelist def get_reverse_complement_tuplelist ( codon_tuplelist ) Get reverse complement of a sequence's tuplelist. View Source def get_reverse_complement_tuplelist ( codon_tuplelist ): \"\"\"Get reverse complement of a sequence's tuplelist.\"\"\" complement_tuplelist = get_complement_tuplelist ( codon_tuplelist ) reverse_complement_tuplelist = get_reverse_tuplelist ( complement_tuplelist ) return reverse_complement_tuplelist get_reverse_tuplelist def get_reverse_tuplelist ( codon_tuplelist ) Get reverse of a tuplelist with reversed triplets. View Source def get_reverse_tuplelist ( codon_tuplelist ) : \"\"\"Get reverse of a tuplelist with reversed triplets.\"\"\" reverse_tuplelist = [] for codon in reversed ( codon_tuplelist ) : reverse_tripletlist = [] for triplet in codon : reverse_triplet = triplet [ ::- 1 ] reverse_tripletlist . append ( reverse_triplet ) reverse_codon = tuple ( reverse_tripletlist ) reverse_tuplelist . append ( reverse_codon ) return reverse_tuplelist make_genealloy def make_genealloy ( host , parasite , swaptable , verbose = True ) Compare two sequence strings and return dictionary of matches. View Source def make_genealloy ( host , parasite , swaptable , verbose = True ): \"\"\"Compare two sequence strings and return dictionary of matches.\"\"\" host_codons = convert_seq_to_codons ( host ) host_tuplelist = convert_codonlist_to_tuplelist ( host_codons , swaptable ) parasite_codons = convert_seq_to_codons ( parasite ) parasite_tuplelist = convert_codonlist_to_tuplelist ( parasite_codons , swaptable ) forward_results = compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix = \"f_\" ) reverse_complement_tuplelist = get_reverse_complement_tuplelist ( host_tuplelist ) reverse_complement_results = compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , reverse_complement_tuplelist , prefix = \"rc_\" ) result = forward_results . copy () result . update ( reverse_complement_results ) if verbose : if all ( value == [] for value in result . values ()): print ( \"These sequences cannot be mixed\" ) else : print ( \"A genealloy can be made using these sequences!\" ) return result walk_seqstep def walk_seqstep ( seqstep ) Compare two sequences by calling advance_step until it returns the result. View Source def walk_seqstep ( seqstep ): \"\"\"Compare two sequences by calling `advance_step` until it returns the result.\"\"\" while not seqstep . result : seqstep . advance_step () Classes Duodon class Duodon ( first_triplet , second_triplet ) Class for storing two triplets View Source class Duodon: \"\"\"Class for storing two triplets\"\"\" def __init__ ( self , first_triplet , second_triplet ): self . first_triplet = first_triplet self . second_triplet = second_triplet SeqStep class SeqStep ( host_tuplelist , parasite_tuplelist , frameshift = 0 , start_host_codon = 0 ) Class for keeping track of sequence comparison It stores a method that aligns a parasite triplet with two consecutive host triplets (duodons), a cursor that marks the position of the comparison process, and methods for generating duodons and comparing them with triplets. The advance_step() method attempts to advance the comparison by one codon step. It can (i) advance the cursor or (ii) conclude that there is no match between the sequences, or (iii) conclude that there is a match. Parameters host_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the host sequence. parasite_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the parasite sequence. frameshift An integer (0, 1 or 2) denoting the frameshift between host and parasite. start_host_codon The host codon position from which the comparison should start. View Source class SeqStep : \"\"\"Class for keeping track of sequence comparison It stores a method that aligns a parasite triplet with two consecutive host triplets (duodons), a cursor that marks the position of the comparison process, and methods for generating duodons and comparing them with triplets. The `advance_step()` method attempts to advance the comparison by one codon step. It can (i) advance the cursor or (ii) conclude that there is no match between the sequences, or (iii) conclude that there is a match. Parameters ---------- host_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the host sequence. parasite_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the parasite sequence. frameshift An integer (0, 1 or 2) denoting the frameshift between host and parasite. start_host_codon The host codon position from which the comparison should start. \"\"\" def __init__ ( self , host_tuplelist , parasite_tuplelist , frameshift = 0 , start_host_codon = 0 ) : self . host_tuplelist = host_tuplelist self . parasite_tuplelist = parasite_tuplelist self . frameshift = frameshift self . start_host_codon = start_host_codon self . cursor = 0 self . len_parasite = len ( parasite_tuplelist ) self . len_host = len ( host_tuplelist ) self . parasite_path = [] self . host_path = [] self . match = False self . result = None def generate_duodons ( self ) : self . cursor self . start_host_codon duodons = [] host_codon = self . start_host_codon + self . cursor if self . host_path == []: # first time it 's made for triplet_1 in self.host_tuplelist[host_codon]: for triplet_2 in self.host_tuplelist[host_codon + 1]: duodons.append(Duodon(triplet_1, triplet_2)) else: triplet_1 = self.host_path[-1].second_triplet # of last used duodon try: for triplet_2 in self.host_tuplelist[host_codon + 1]: duodons.append(Duodon(triplet_1, triplet_2)) except: duodons.append(Duodon(triplet_1, \"NNN\")) return duodons def return_all_matching_duodons(self, triplet, duodons, frameshift=0): matching_duodons = [] for duodon in duodons: host_letters = duodon.first_triplet + duodon.second_triplet # compare 1st letter: if not compare_letters(host_letters[0 + frameshift], triplet[0]): continue if not compare_letters(host_letters[1 + frameshift], triplet[1]): continue if not compare_letters(host_letters[2 + frameshift], triplet[2]): continue matching_duodons.append(duodon) return matching_duodons def compare_triplet_and_duodon(self, triplet, duodon, frameshift=0): host_letters = duodon.first_triplet + duodon.second_triplet if not compare_letters(host_letters[0 + frameshift], triplet[0]): return False if not compare_letters(host_letters[1 + frameshift], triplet[1]): return False if not compare_letters(host_letters[2 + frameshift], triplet[2]): return False return True def advance_step(self): if self.result: return self.result if self.cursor == self.len_parasite: self.match = True self.result = ( \"Match found between parasite and host sequence. Start codon was: \" + str(self.start_host_codon) ) return self.result parasite_triplets = list(self.parasite_tuplelist[self.cursor]) host_duodons = self.generate_duodons() while True: try: parasite_triplet = parasite_triplets[0] except: self.result = \"Sequences don' t match . Start codon was : \" + str( self.start_host_codon ) return self.result else: host_duodons_for_parasite_triplet = host_duodons[:] host_duodons_for_parasite_triplet = self.return_all_matching_duodons( parasite_triplet, host_duodons_for_parasite_triplet, frameshift=self.frameshift, ) self.parasite_path.append(parasite_triplet) while True: try: host_doudon = host_duodons_for_parasite_triplet[0] except: self.parasite_path.pop() del parasite_triplets[0] break else: if self.compare_triplet_and_duodon( parasite_triplet, host_doudon, frameshift=self.frameshift ): self.host_path.append(host_doudon) self.cursor += 1 return \" Codon matched , cursor advanced \" else : del host_duodons_for_parasite_triplet [ 0 ] Methods advance_step def advance_step ( self ) View Source def advance_step ( self ): if self . result : return self . result if self . cursor == self . len_parasite : self . match = True self . result = ( \"Match found between parasite and host sequence. Start codon was: \" + str ( self . start_host_codon ) ) return self . result parasite_triplets = list ( self . parasite_tuplelist [ self . cursor ]) host_duodons = self . generate_duodons () while True : try : parasite_triplet = parasite_triplets [ 0 ] except : self . result = \"Sequences don't match. Start codon was: \" + str ( self . start_host_codon ) return self . result else : host_duodons_for_parasite_triplet = host_duodons [:] host_duodons_for_parasite_triplet = self . return_all_matching_duodons ( parasite_triplet , host_duodons_for_parasite_triplet , frameshift = self . frameshift , ) self . parasite_path . append ( parasite_triplet ) while True : try : host_doudon = host_duodons_for_parasite_triplet [ 0 ] except : self . parasite_path . pop () del parasite_triplets [ 0 ] break else : if self . compare_triplet_and_duodon ( parasite_triplet , host_doudon , frameshift = self . frameshift ): self . host_path . append ( host_doudon ) self . cursor += 1 return \"Codon matched, cursor advanced\" else : del host_duodons_for_parasite_triplet [ 0 ] compare_triplet_and_duodon def compare_triplet_and_duodon ( self , triplet , duodon , frameshift = 0 ) View Source def compare_triplet_and_duodon ( self , triplet , duodon , frameshift = 0 ): host_letters = duodon . first_triplet + duodon . second_triplet if not compare_letters ( host_letters [ 0 + frameshift ], triplet [ 0 ]): return False if not compare_letters ( host_letters [ 1 + frameshift ], triplet [ 1 ]): return False if not compare_letters ( host_letters [ 2 + frameshift ], triplet [ 2 ]): return False return True generate_duodons def generate_duodons ( self ) View Source def generate_duodons ( self ) : self . cursor self . start_host_codon duodons = [] host_codon = self . start_host_codon + self . cursor if self . host_path == []: # first time it ' s made for triplet_1 in self . host_tuplelist [ host_codon ] : for triplet_2 in self . host_tuplelist [ host_codon + 1 ] : duodons . append ( Duodon ( triplet_1 , triplet_2 )) else : triplet_1 = self . host_path [ -1 ] . second_triplet # of last used duodon try : for triplet_2 in self . host_tuplelist [ host_codon + 1 ] : duodons . append ( Duodon ( triplet_1 , triplet_2 )) except : duodons . append ( Duodon ( triplet_1 , \"NNN\" )) return duodons return_all_matching_duodons def return_all_matching_duodons ( self , triplet , duodons , frameshift = 0 ) View Source def return_all_matching_duodons ( self , triplet , duodons , frameshift = 0 ): matching_duodons = [] for duodon in duodons : host_letters = duodon . first_triplet + duodon . second_triplet # compare 1 st letter : if not compare_letters ( host_letters [ 0 + frameshift ], triplet [ 0 ]): continue if not compare_letters ( host_letters [ 1 + frameshift ], triplet [ 1 ]): continue if not compare_letters ( host_letters [ 2 + frameshift ], triplet [ 2 ]): continue matching_duodons . append ( duodon ) return matching_duodons","title":"Genealloy"},{"location":"reference/genealloy/genealloy/#module-genealloygenealloy","text":"View Source from . codontable import ( codon_to_aa , aa_to_codon_extended , codon_extended_to_aa , complement_table , compare_letters , ) def convert_seq_to_codons ( seq ) : \"\"\"Convert a string (sequence) into a list of 3-letter strings (triplets).\"\"\" seq_codons = [ seq [ i : i + 3 ] for i in range ( 0 , len ( seq ), 3 )] return seq_codons def convert_codonlist_to_tuplelist ( seq_codons , codon_to_codon_extended ) : \"\"\"Convert a list of triplets into a list of tuples, using a swaptable. The swaptable is a dict of triplet: triplets, and determines the allowed swaps. \"\"\" codon_extended = [ None ] * len ( seq_codons ) for i , codon in enumerate ( seq_codons ) : codon_extended [ i ] = codon_to_codon_extended [ codon ] return codon_extended def get_next_letter ( sequence_tuplelist , current_letter_index ) : \"\"\"Get next letter in the sequence.\"\"\" letter_index = current_letter_index if current_letter_index [ 2 ] == 2 : # last letter of triplet , advance to next codon : letter_index = [ letter_index [ 0 ] + 1 , 0 , 0 ] try : i , j , k = letter_index [ 0 ], letter_index [ 1 ], letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ], letter_index ) return letter except : raise else : # letter is not the last in triplet , get the next one : letter_index [ 2 ] = letter_index [ 2 ] + 1 i , j , k = letter_index [ 0 ], letter_index [ 1 ], letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ], letter_index ) return letter def get_letter_in_next_triplet ( sequence_tuplelist , current_letter_index ) : \"\"\"Get first letter in the next triplet.\"\"\" letter_index = current_letter_index letter_index [ 1 ] = letter_index [ 1 ] + 1 # triplet position letter_index [ 2 ] = 0 # move letter position to triplet's first letter try: i, j, k = letter_index[0], letter_index[1], letter_index[2] letter = (sequence_tuplelist[i][j][k], letter_index) return letter except: raise def compare_then_get_letter_recursively( host_tuplelist, parasite_tuplelist, host_letter, parasite_letter ): \"\"\"Compare two letters then get next pair of letters recursively. Returns string for match or no match between the sequences. \"\"\" # This function works only for in-frame comparisons and is given the first # letters of the host and parasite sequences. If the two letters match, # then gets the next parasite and host letters, and calls itself. # If can't get next parasite letter , then the comparison has finished # and a full match has been found . # If letters do not match , then gets the next parasite triplet and calls # itself ; if there are no more parasite triplets , it gets the next host # triplet and calls itself . If there are no more host triplets , then there is # no match between the sequences . is_match = compare_letters ( host_letter [ 0 ], parasite_letter [ 0 ]) if is_match: try : next_parasite_letter = get_next_letter ( parasite_tuplelist , parasite_letter [ 1 ] ) except : return str ( \"Finished parasite sequence, match found! Ending host position:\" + str ( host_letter [ 1 ]) ) else : next_host_letter = get_next_letter ( host_tuplelist , host_letter [ 1 ] ) # always OK return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) else : # letters do not match , move on to next parasite triplet try : next_parasite_letter = get_letter_in_next_triplet ( parasite_tuplelist , parasite_letter [ 1 ] ) except : # no more parasite triplet , get next host try : next_host_letter = get_letter_in_next_triplet ( host_tuplelist , host_letter [ 1 ] ) except : return \"No match for this starting codon position\" else : i = parasite_letter [ 1 ][ 0 ] # same codon j , k = 0 , 0 # reset parasite to first triplet , first letter next_parasite_letter = ( parasite_tuplelist [ i ][ j ][ k ], [ i , j , k ]) return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) else : i , j = host_letter [ 1 ][ 0 ], host_letter [ 1 ][ 1 ] # same codon , same triplet k = 0 # reset host letter to beginning of triplet because parasite was reset next_host_letter = ( host_tuplelist [ i ][ j ][ k ], [ i , j , k ]) return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) def walk_seqstep ( seqstep ) : \"\"\"Compare two sequences by calling `advance_step` until it returns the result.\"\"\" while not seqstep . result : seqstep . advance_step () def compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ) : \"\"\"Compare two sequence's tuplists for given frame and return list of matches.\"\"\" len_parasite = len ( parasite_tuplelist ) len_host = len ( host_tuplelist ) list_of_matches = [] for start_host_codon in range ( 0 , len_host - len_parasite + 1 ) : seqstep = SeqStep ( host_tuplelist , parasite_tuplelist , start_host_codon = start_host_codon , frameshift = frameshift , ) walk_seqstep ( seqstep ) if seqstep . match : list_of_matches . append ( start_host_codon ) return list_of_matches def compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix= \"\" ) : \"\"\"Compare two sequence's tuplists for all frames and return dict of matches.\"\"\" results_for_all_frames = dict () for frameshift in [ 0 , 1 , 2 ] : result = compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ) key = prefix + str ( frameshift ) results_for_all_frames [ key ] = result return results_for_all_frames def find_partial_overlaps ( host , parasite , swaptable , verbose = True ) : flank = len ( parasite ) * \"N\" host_flank = flank + host + flank swaptable [ \"NNN\" ] = ( \"NNN\" ,) result = make_genealloy ( host_flank , parasite , swaptable , verbose = True ) return result def make_genealloy ( host , parasite , swaptable , verbose = True ) : \"\"\"Compare two sequence strings and return dictionary of matches.\"\"\" host_codons = convert_seq_to_codons ( host ) host_tuplelist = convert_codonlist_to_tuplelist ( host_codons , swaptable ) parasite_codons = convert_seq_to_codons ( parasite ) parasite_tuplelist = convert_codonlist_to_tuplelist ( parasite_codons , swaptable ) forward_results = compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix= \"f_\" ) reverse_complement_tuplelist = get_reverse_complement_tuplelist ( host_tuplelist ) reverse_complement_results = compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , reverse_complement_tuplelist , prefix= \"rc_\" ) result = forward_results . copy () result . update ( reverse_complement_results ) if verbose : if all ( value == [] for value in result . values ()) : print ( \"These sequences cannot be mixed\" ) else : print ( \"A genealloy can be made using these sequences!\" ) return result def get_complement_tuplelist ( codon_tuplelist ) : \"\"\"Get complement triplets of a sequence tuplelist.\"\"\" complement_tuplelist = [] for index , codon in enumerate ( codon_tuplelist ) : complement_tripletlist = [] for triplet in codon : letter1 = triplet [ 0 ] letter2 = triplet [ 1 ] letter3 = triplet [ 2 ] complement_triplet = ( complement_table [ letter1 ] + complement_table [ letter2 ] + complement_table [ letter3 ] ) complement_tripletlist . append ( complement_triplet ) complement_codon = tuple ( complement_tripletlist ) complement_tuplelist . append ( complement_codon ) return complement_tuplelist def get_reverse_tuplelist ( codon_tuplelist ) : \"\"\"Get reverse of a tuplelist with reversed triplets.\"\"\" reverse_tuplelist = [] for codon in reversed ( codon_tuplelist ) : reverse_tripletlist = [] for triplet in codon : reverse_triplet = triplet [ ::- 1 ] reverse_tripletlist . append ( reverse_triplet ) reverse_codon = tuple ( reverse_tripletlist ) reverse_tuplelist . append ( reverse_codon ) return reverse_tuplelist def get_reverse_complement_tuplelist ( codon_tuplelist ) : \"\"\"Get reverse complement of a sequence's tuplelist.\"\"\" complement_tuplelist = get_complement_tuplelist ( codon_tuplelist ) reverse_complement_tuplelist = get_reverse_tuplelist ( complement_tuplelist ) return reverse_complement_tuplelist class Duodon : \"\"\"Class for storing two triplets\"\"\" def __ init__ ( self , first_triplet , second_triplet ) : self . first_triplet = first_triplet self . second_triplet = second_triplet class SeqStep : \"\"\"Class for keeping track of sequence comparison It stores a method that aligns a parasite triplet with two consecutive host triplets (duodons), a cursor that marks the position of the comparison process, and methods for generating duodons and comparing them with triplets. The `advance_step()` method attempts to advance the comparison by one codon step. It can (i) advance the cursor or (ii) conclude that there is no match between the sequences, or (iii) conclude that there is a match. Parameters ---------- host_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the host sequence. parasite_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the parasite sequence. frameshift An integer (0, 1 or 2) denoting the frameshift between host and parasite. start_host_codon The host codon position from which the comparison should start. \"\"\" def __ init__ ( self , host_tuplelist , parasite_tuplelist , frameshift = 0 , start_host_codon = 0 ) : self . host_tuplelist = host_tuplelist self . parasite_tuplelist = parasite_tuplelist self . frameshift = frameshift self . start_host_codon = start_host_codon self . cursor = 0 self . len_parasite = len ( parasite_tuplelist ) self . len_host = len ( host_tuplelist ) self . parasite_path = [] self . host_path = [] self . match = False self . result = None def generate_duodons ( self ) : self . cursor self . start_host_codon duodons = [] host_codon = self . start_host_codon + self . cursor if self . host_path == [] : # first time it's made for triplet_1 in self.host_tuplelist[host_codon]: for triplet_2 in self.host_tuplelist[host_codon + 1]: duodons.append(Duodon(triplet_1, triplet_2)) else: triplet_1 = self.host_path[-1].second_triplet # of last used duodon try: for triplet_2 in self.host_tuplelist[host_codon + 1]: duodons.append(Duodon(triplet_1, triplet_2)) except: duodons.append(Duodon(triplet_1, \"NNN\")) return duodons def return_all_matching_duodons(self, triplet, duodons, frameshift=0): matching_duodons = [] for duodon in duodons: host_letters = duodon.first_triplet + duodon.second_triplet # compare 1st letter: if not compare_letters(host_letters[0 + frameshift], triplet[0]): continue if not compare_letters(host_letters[1 + frameshift], triplet[1]): continue if not compare_letters(host_letters[2 + frameshift], triplet[2]): continue matching_duodons.append(duodon) return matching_duodons def compare_triplet_and_duodon(self, triplet, duodon, frameshift=0): host_letters = duodon.first_triplet + duodon.second_triplet if not compare_letters(host_letters[0 + frameshift], triplet[0]): return False if not compare_letters(host_letters[1 + frameshift], triplet[1]): return False if not compare_letters(host_letters[2 + frameshift], triplet[2]): return False return True def advance_step(self): if self.result: return self.result if self.cursor == self.len_parasite: self.match = True self.result = ( \"Match found between parasite and host sequence. Start codon was: \" + str(self.start_host_codon) ) return self.result parasite_triplets = list(self.parasite_tuplelist[self.cursor]) host_duodons = self.generate_duodons() while True: try: parasite_triplet = parasite_triplets[0] except: self.result = \"Sequences don't match . Start codon was : \" + str( self.start_host_codon ) return self.result else: host_duodons_for_parasite_triplet = host_duodons[:] host_duodons_for_parasite_triplet = self.return_all_matching_duodons( parasite_triplet, host_duodons_for_parasite_triplet, frameshift=self.frameshift, ) self.parasite_path.append(parasite_triplet) while True: try: host_doudon = host_duodons_for_parasite_triplet[0] except: self.parasite_path.pop() del parasite_triplets[0] break else: if self.compare_triplet_and_duodon( parasite_triplet, host_doudon, frameshift=self.frameshift ): self.host_path.append(host_doudon) self.cursor += 1 return \" Codon matched , cursor advanced \" else : del host_duodons_for_parasite_triplet [ 0 ]","title":"Module genealloy.genealloy"},{"location":"reference/genealloy/genealloy/#variables","text":"aa_to_codon_extended codon_extended_to_aa codon_to_aa complement_table","title":"Variables"},{"location":"reference/genealloy/genealloy/#functions","text":"","title":"Functions"},{"location":"reference/genealloy/genealloy/#compare_sequence_tuplelists","text":"def compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ) Compare two sequence's tuplists for given frame and return list of matches. View Source def compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ): \"\"\"Compare two sequence's tuplists for given frame and return list of matches.\"\"\" len_parasite = len ( parasite_tuplelist ) len_host = len ( host_tuplelist ) list_of_matches = [] for start_host_codon in range ( 0 , len_host - len_parasite + 1 ): seqstep = SeqStep ( host_tuplelist , parasite_tuplelist , start_host_codon = start_host_codon , frameshift = frameshift , ) walk_seqstep ( seqstep ) if seqstep . match : list_of_matches . append ( start_host_codon ) return list_of_matches","title":"compare_sequence_tuplelists"},{"location":"reference/genealloy/genealloy/#compare_sequence_tuplelists_in_all_frames","text":"def compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix = '' ) Compare two sequence's tuplists for all frames and return dict of matches. View Source def compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix = \"\" ) : \"\"\"Compare two sequence's tuplists for all frames and return dict of matches.\"\"\" results_for_all_frames = dict () for frameshift in [ 0, 1, 2 ] : result = compare_sequence_tuplelists ( parasite_tuplelist , host_tuplelist , frameshift ) key = prefix + str ( frameshift ) results_for_all_frames [ key ] = result return results_for_all_frames","title":"compare_sequence_tuplelists_in_all_frames"},{"location":"reference/genealloy/genealloy/#compare_then_get_letter_recursively","text":"def compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , host_letter , parasite_letter ) Compare two letters then get next pair of letters recursively. Returns string for match or no match between the sequences. View Source def compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , host_letter , parasite_letter ) : \"\"\"Compare two letters then get next pair of letters recursively. Returns string for match or no match between the sequences. \"\"\" # This function works only for in - frame comparisons and is given the first # letters of the host and parasite sequences . If the two letters match , # then gets the next parasite and host letters , and calls itself . # If can ' t get next parasite letter , then the comparison has finished # and a full match has been found . # If letters do not match , then gets the next parasite triplet and calls # itself ; if there are no more parasite triplets , it gets the next host # triplet and calls itself . If there are no more host triplets , then there is # no match between the sequences . is_match = compare_letters ( host_letter [ 0 ] , parasite_letter [ 0 ] ) if is_match : try : next_parasite_letter = get_next_letter ( parasite_tuplelist , parasite_letter [ 1 ] ) except : return str ( \"Finished parasite sequence, match found! Ending host position:\" + str ( host_letter [ 1 ] ) ) else : next_host_letter = get_next_letter ( host_tuplelist , host_letter [ 1 ] ) # always OK return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) else : # letters do not match , move on to next parasite triplet try : next_parasite_letter = get_letter_in_next_triplet ( parasite_tuplelist , parasite_letter [ 1 ] ) except : # no more parasite triplet , get next host try : next_host_letter = get_letter_in_next_triplet ( host_tuplelist , host_letter [ 1 ] ) except : return \"No match for this starting codon position\" else : i = parasite_letter [ 1 ][ 0 ] # same codon j , k = 0 , 0 # reset parasite to first triplet , first letter next_parasite_letter = ( parasite_tuplelist [ i ][ j ][ k ] , [ i, j, k ] ) return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , ) else : i , j = host_letter [ 1 ][ 0 ] , host_letter [ 1 ][ 1 ] # same codon , same triplet k = 0 # reset host letter to beginning of triplet because parasite was reset next_host_letter = ( host_tuplelist [ i ][ j ][ k ] , [ i, j, k ] ) return compare_then_get_letter_recursively ( host_tuplelist , parasite_tuplelist , next_host_letter , next_parasite_letter , )","title":"compare_then_get_letter_recursively"},{"location":"reference/genealloy/genealloy/#convert_codonlist_to_tuplelist","text":"def convert_codonlist_to_tuplelist ( seq_codons , codon_to_codon_extended ) Convert a list of triplets into a list of tuples, using a swaptable. The swaptable is a dict of triplet: triplets, and determines the allowed swaps. View Source def convert_codonlist_to_tuplelist ( seq_codons , codon_to_codon_extended ) : \"\"\"Convert a list of triplets into a list of tuples, using a swaptable. The swaptable is a dict of triplet: triplets, and determines the allowed swaps. \"\"\" codon_extended = [ None ] * len ( seq_codons ) for i , codon in enumerate ( seq_codons ) : codon_extended [ i ] = codon_to_codon_extended [ codon ] return codon_extended","title":"convert_codonlist_to_tuplelist"},{"location":"reference/genealloy/genealloy/#convert_seq_to_codons","text":"def convert_seq_to_codons ( seq ) Convert a string (sequence) into a list of 3-letter strings (triplets). View Source def convert_seq_to_codons ( seq ) : \"\"\"Convert a string (sequence) into a list of 3-letter strings (triplets).\"\"\" seq_codons = [ seq [ i : i + 3 ] for i in range ( 0 , len ( seq ), 3 )] return seq_codons","title":"convert_seq_to_codons"},{"location":"reference/genealloy/genealloy/#find_partial_overlaps","text":"def find_partial_overlaps ( host , parasite , swaptable , verbose = True ) View Source def find_partial_overlaps ( host , parasite , swaptable , verbose = True ): flank = len ( parasite ) * \"N\" host_flank = flank + host + flank swaptable [ \"NNN\" ] = ( \"NNN\" ,) result = make_genealloy ( host_flank , parasite , swaptable , verbose = True ) return result","title":"find_partial_overlaps"},{"location":"reference/genealloy/genealloy/#get_complement_tuplelist","text":"def get_complement_tuplelist ( codon_tuplelist ) Get complement triplets of a sequence tuplelist. View Source def get_complement_tuplelist ( codon_tuplelist ) : \"\"\"Get complement triplets of a sequence tuplelist.\"\"\" complement_tuplelist = [] for index , codon in enumerate ( codon_tuplelist ) : complement_tripletlist = [] for triplet in codon : letter1 = triplet [ 0 ] letter2 = triplet [ 1 ] letter3 = triplet [ 2 ] complement_triplet = ( complement_table [ letter1 ] + complement_table [ letter2 ] + complement_table [ letter3 ] ) complement_tripletlist . append ( complement_triplet ) complement_codon = tuple ( complement_tripletlist ) complement_tuplelist . append ( complement_codon ) return complement_tuplelist","title":"get_complement_tuplelist"},{"location":"reference/genealloy/genealloy/#get_letter_in_next_triplet","text":"def get_letter_in_next_triplet ( sequence_tuplelist , current_letter_index ) Get first letter in the next triplet. View Source def get_letter_in_next_triplet ( sequence_tuplelist , current_letter_index ) : \"\"\"Get first letter in the next triplet.\"\"\" letter_index = current_letter_index letter_index [ 1 ] = letter_index [ 1 ] + 1 # triplet position letter_index [ 2 ] = 0 # move letter position to triplet ' s first letter try : i , j , k = letter_index [ 0 ] , letter_index [ 1 ] , letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ] , letter_index ) return letter except : raise","title":"get_letter_in_next_triplet"},{"location":"reference/genealloy/genealloy/#get_next_letter","text":"def get_next_letter ( sequence_tuplelist , current_letter_index ) Get next letter in the sequence. View Source def get_next_letter ( sequence_tuplelist , current_letter_index ) : \"\"\"Get next letter in the sequence.\"\"\" letter_index = current_letter_index if current_letter_index [ 2 ] == 2 : # last letter of triplet , advance to next codon : letter_index = [ letter_index[0 ] + 1 , 0 , 0 ] try : i , j , k = letter_index [ 0 ] , letter_index [ 1 ] , letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ] , letter_index ) return letter except : raise else : # letter is not the last in triplet , get the next one : letter_index [ 2 ] = letter_index [ 2 ] + 1 i , j , k = letter_index [ 0 ] , letter_index [ 1 ] , letter_index [ 2 ] letter = ( sequence_tuplelist [ i ][ j ][ k ] , letter_index ) return letter","title":"get_next_letter"},{"location":"reference/genealloy/genealloy/#get_reverse_complement_tuplelist","text":"def get_reverse_complement_tuplelist ( codon_tuplelist ) Get reverse complement of a sequence's tuplelist. View Source def get_reverse_complement_tuplelist ( codon_tuplelist ): \"\"\"Get reverse complement of a sequence's tuplelist.\"\"\" complement_tuplelist = get_complement_tuplelist ( codon_tuplelist ) reverse_complement_tuplelist = get_reverse_tuplelist ( complement_tuplelist ) return reverse_complement_tuplelist","title":"get_reverse_complement_tuplelist"},{"location":"reference/genealloy/genealloy/#get_reverse_tuplelist","text":"def get_reverse_tuplelist ( codon_tuplelist ) Get reverse of a tuplelist with reversed triplets. View Source def get_reverse_tuplelist ( codon_tuplelist ) : \"\"\"Get reverse of a tuplelist with reversed triplets.\"\"\" reverse_tuplelist = [] for codon in reversed ( codon_tuplelist ) : reverse_tripletlist = [] for triplet in codon : reverse_triplet = triplet [ ::- 1 ] reverse_tripletlist . append ( reverse_triplet ) reverse_codon = tuple ( reverse_tripletlist ) reverse_tuplelist . append ( reverse_codon ) return reverse_tuplelist","title":"get_reverse_tuplelist"},{"location":"reference/genealloy/genealloy/#make_genealloy","text":"def make_genealloy ( host , parasite , swaptable , verbose = True ) Compare two sequence strings and return dictionary of matches. View Source def make_genealloy ( host , parasite , swaptable , verbose = True ): \"\"\"Compare two sequence strings and return dictionary of matches.\"\"\" host_codons = convert_seq_to_codons ( host ) host_tuplelist = convert_codonlist_to_tuplelist ( host_codons , swaptable ) parasite_codons = convert_seq_to_codons ( parasite ) parasite_tuplelist = convert_codonlist_to_tuplelist ( parasite_codons , swaptable ) forward_results = compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , host_tuplelist , prefix = \"f_\" ) reverse_complement_tuplelist = get_reverse_complement_tuplelist ( host_tuplelist ) reverse_complement_results = compare_sequence_tuplelists_in_all_frames ( parasite_tuplelist , reverse_complement_tuplelist , prefix = \"rc_\" ) result = forward_results . copy () result . update ( reverse_complement_results ) if verbose : if all ( value == [] for value in result . values ()): print ( \"These sequences cannot be mixed\" ) else : print ( \"A genealloy can be made using these sequences!\" ) return result","title":"make_genealloy"},{"location":"reference/genealloy/genealloy/#walk_seqstep","text":"def walk_seqstep ( seqstep ) Compare two sequences by calling advance_step until it returns the result. View Source def walk_seqstep ( seqstep ): \"\"\"Compare two sequences by calling `advance_step` until it returns the result.\"\"\" while not seqstep . result : seqstep . advance_step ()","title":"walk_seqstep"},{"location":"reference/genealloy/genealloy/#classes","text":"","title":"Classes"},{"location":"reference/genealloy/genealloy/#duodon","text":"class Duodon ( first_triplet , second_triplet ) Class for storing two triplets View Source class Duodon: \"\"\"Class for storing two triplets\"\"\" def __init__ ( self , first_triplet , second_triplet ): self . first_triplet = first_triplet self . second_triplet = second_triplet","title":"Duodon"},{"location":"reference/genealloy/genealloy/#seqstep","text":"class SeqStep ( host_tuplelist , parasite_tuplelist , frameshift = 0 , start_host_codon = 0 ) Class for keeping track of sequence comparison It stores a method that aligns a parasite triplet with two consecutive host triplets (duodons), a cursor that marks the position of the comparison process, and methods for generating duodons and comparing them with triplets. The advance_step() method attempts to advance the comparison by one codon step. It can (i) advance the cursor or (ii) conclude that there is no match between the sequences, or (iii) conclude that there is a match.","title":"SeqStep"},{"location":"reference/genealloy/genealloy/#parameters","text":"host_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the host sequence. parasite_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the parasite sequence. frameshift An integer (0, 1 or 2) denoting the frameshift between host and parasite. start_host_codon The host codon position from which the comparison should start. View Source class SeqStep : \"\"\"Class for keeping track of sequence comparison It stores a method that aligns a parasite triplet with two consecutive host triplets (duodons), a cursor that marks the position of the comparison process, and methods for generating duodons and comparing them with triplets. The `advance_step()` method attempts to advance the comparison by one codon step. It can (i) advance the cursor or (ii) conclude that there is no match between the sequences, or (iii) conclude that there is a match. Parameters ---------- host_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the host sequence. parasite_tuplelist A list of tuples. Each tuple stores the allowed triplets for a codon position of the parasite sequence. frameshift An integer (0, 1 or 2) denoting the frameshift between host and parasite. start_host_codon The host codon position from which the comparison should start. \"\"\" def __init__ ( self , host_tuplelist , parasite_tuplelist , frameshift = 0 , start_host_codon = 0 ) : self . host_tuplelist = host_tuplelist self . parasite_tuplelist = parasite_tuplelist self . frameshift = frameshift self . start_host_codon = start_host_codon self . cursor = 0 self . len_parasite = len ( parasite_tuplelist ) self . len_host = len ( host_tuplelist ) self . parasite_path = [] self . host_path = [] self . match = False self . result = None def generate_duodons ( self ) : self . cursor self . start_host_codon duodons = [] host_codon = self . start_host_codon + self . cursor if self . host_path == []: # first time it 's made for triplet_1 in self.host_tuplelist[host_codon]: for triplet_2 in self.host_tuplelist[host_codon + 1]: duodons.append(Duodon(triplet_1, triplet_2)) else: triplet_1 = self.host_path[-1].second_triplet # of last used duodon try: for triplet_2 in self.host_tuplelist[host_codon + 1]: duodons.append(Duodon(triplet_1, triplet_2)) except: duodons.append(Duodon(triplet_1, \"NNN\")) return duodons def return_all_matching_duodons(self, triplet, duodons, frameshift=0): matching_duodons = [] for duodon in duodons: host_letters = duodon.first_triplet + duodon.second_triplet # compare 1st letter: if not compare_letters(host_letters[0 + frameshift], triplet[0]): continue if not compare_letters(host_letters[1 + frameshift], triplet[1]): continue if not compare_letters(host_letters[2 + frameshift], triplet[2]): continue matching_duodons.append(duodon) return matching_duodons def compare_triplet_and_duodon(self, triplet, duodon, frameshift=0): host_letters = duodon.first_triplet + duodon.second_triplet if not compare_letters(host_letters[0 + frameshift], triplet[0]): return False if not compare_letters(host_letters[1 + frameshift], triplet[1]): return False if not compare_letters(host_letters[2 + frameshift], triplet[2]): return False return True def advance_step(self): if self.result: return self.result if self.cursor == self.len_parasite: self.match = True self.result = ( \"Match found between parasite and host sequence. Start codon was: \" + str(self.start_host_codon) ) return self.result parasite_triplets = list(self.parasite_tuplelist[self.cursor]) host_duodons = self.generate_duodons() while True: try: parasite_triplet = parasite_triplets[0] except: self.result = \"Sequences don' t match . Start codon was : \" + str( self.start_host_codon ) return self.result else: host_duodons_for_parasite_triplet = host_duodons[:] host_duodons_for_parasite_triplet = self.return_all_matching_duodons( parasite_triplet, host_duodons_for_parasite_triplet, frameshift=self.frameshift, ) self.parasite_path.append(parasite_triplet) while True: try: host_doudon = host_duodons_for_parasite_triplet[0] except: self.parasite_path.pop() del parasite_triplets[0] break else: if self.compare_triplet_and_duodon( parasite_triplet, host_doudon, frameshift=self.frameshift ): self.host_path.append(host_doudon) self.cursor += 1 return \" Codon matched , cursor advanced \" else : del host_duodons_for_parasite_triplet [ 0 ]","title":"Parameters"},{"location":"reference/genealloy/genealloy/#methods","text":"","title":"Methods"},{"location":"reference/genealloy/genealloy/#advance_step","text":"def advance_step ( self ) View Source def advance_step ( self ): if self . result : return self . result if self . cursor == self . len_parasite : self . match = True self . result = ( \"Match found between parasite and host sequence. Start codon was: \" + str ( self . start_host_codon ) ) return self . result parasite_triplets = list ( self . parasite_tuplelist [ self . cursor ]) host_duodons = self . generate_duodons () while True : try : parasite_triplet = parasite_triplets [ 0 ] except : self . result = \"Sequences don't match. Start codon was: \" + str ( self . start_host_codon ) return self . result else : host_duodons_for_parasite_triplet = host_duodons [:] host_duodons_for_parasite_triplet = self . return_all_matching_duodons ( parasite_triplet , host_duodons_for_parasite_triplet , frameshift = self . frameshift , ) self . parasite_path . append ( parasite_triplet ) while True : try : host_doudon = host_duodons_for_parasite_triplet [ 0 ] except : self . parasite_path . pop () del parasite_triplets [ 0 ] break else : if self . compare_triplet_and_duodon ( parasite_triplet , host_doudon , frameshift = self . frameshift ): self . host_path . append ( host_doudon ) self . cursor += 1 return \"Codon matched, cursor advanced\" else : del host_duodons_for_parasite_triplet [ 0 ]","title":"advance_step"},{"location":"reference/genealloy/genealloy/#compare_triplet_and_duodon","text":"def compare_triplet_and_duodon ( self , triplet , duodon , frameshift = 0 ) View Source def compare_triplet_and_duodon ( self , triplet , duodon , frameshift = 0 ): host_letters = duodon . first_triplet + duodon . second_triplet if not compare_letters ( host_letters [ 0 + frameshift ], triplet [ 0 ]): return False if not compare_letters ( host_letters [ 1 + frameshift ], triplet [ 1 ]): return False if not compare_letters ( host_letters [ 2 + frameshift ], triplet [ 2 ]): return False return True","title":"compare_triplet_and_duodon"},{"location":"reference/genealloy/genealloy/#generate_duodons","text":"def generate_duodons ( self ) View Source def generate_duodons ( self ) : self . cursor self . start_host_codon duodons = [] host_codon = self . start_host_codon + self . cursor if self . host_path == []: # first time it ' s made for triplet_1 in self . host_tuplelist [ host_codon ] : for triplet_2 in self . host_tuplelist [ host_codon + 1 ] : duodons . append ( Duodon ( triplet_1 , triplet_2 )) else : triplet_1 = self . host_path [ -1 ] . second_triplet # of last used duodon try : for triplet_2 in self . host_tuplelist [ host_codon + 1 ] : duodons . append ( Duodon ( triplet_1 , triplet_2 )) except : duodons . append ( Duodon ( triplet_1 , \"NNN\" )) return duodons","title":"generate_duodons"},{"location":"reference/genealloy/genealloy/#return_all_matching_duodons","text":"def return_all_matching_duodons ( self , triplet , duodons , frameshift = 0 ) View Source def return_all_matching_duodons ( self , triplet , duodons , frameshift = 0 ): matching_duodons = [] for duodon in duodons : host_letters = duodon . first_triplet + duodon . second_triplet # compare 1 st letter : if not compare_letters ( host_letters [ 0 + frameshift ], triplet [ 0 ]): continue if not compare_letters ( host_letters [ 1 + frameshift ], triplet [ 1 ]): continue if not compare_letters ( host_letters [ 2 + frameshift ], triplet [ 2 ]): continue matching_duodons . append ( duodon ) return matching_duodons","title":"return_all_matching_duodons"},{"location":"reference/genealloy/version/","text":"Module genealloy.version View Source __version__ = \"0.1.0\"","title":"Version"},{"location":"reference/genealloy/version/#module-genealloyversion","text":"View Source __version__ = \"0.1.0\"","title":"Module genealloy.version"}]}